= slide 'Днес' do
  list:
    Програмиране за web с Ruby
    HTTP сървъри, deployment и Rack
    Sinatra

= slide 'Преди това', 'въпроси около метапрограмиране и обектния модел в Ruby' do
  p Споделете поне три различни начина за дефиниране инстанционни методи в клас.

  .answer
    list:
      `def something; end`
      `define_method :something { |args| }`
      `eval()`

= slide 'Въпрос 2' do
  p Какво прави <code>instance_eval</code>?

  .answer.action
    p <code>instance_eval</code> променя <code>self</code> в рамките на един блок

= slide 'Въпрос 3' do
  p Ако искате да напишете клас-прокси, кой ще бъде родителският ви клас?

  .answer
    list:
      `BasicObject`
      Защо не `Object`?
      В `Object` има твърде много методи, за разлика от `BasicObject`

= slide 'Въпрос 4' do
  p Как могат да се създават анонимни класове и/или модули?

  .answer.action
    p Посредством <code>Class.new { block }</code> и <code>Module.new { block }</code>

= slide 'Въпрос 5' do
  p Що е то <code>singleton class</code> на обект? Какво знаете за него?

  .answer
    list:
      За всеки обект при нужда се създава специален клас, наречен singleton class
      Съдържа методите, добавени специално към този обект
      Известен е още като metaclass, eigenclass и собствен клас
      `Symbol` и `Fixnum` нямат собствени класове

= slide 'Въпрос 6' do
  p 1. Къде се пазят инстанционните методи?
  p.action.answer В модули (класове).
  p.action 2. Къде се пазят инстанционните методи, уникални за дадена инстанция?
  p.action.answer В специално създадения за нея singleton клас.

= slide 'Въпрос 7' do
  p 1. Къде се пазят класовите методи? Защо?
  p.action.answer
    | В singleton класа на текущия клас. Защото всеки клас е обект (инстанция) от тип
      <code>Class</code> и всички "класови" методи, които има, са всъщност инстанционни,
      уникални за тази конкретна инстанция на <code>Class</code>.
  p.action 2. Ако имаме <code>class A; end</code> и <code>class B < A; end</code>, то какво е <code>B.singleton_class.superclass</code>?
  p.action.answer Родителският клас на <code>B.singleton_class</code> е <code>A.singleton_class</code>.

= slide 'Уеб с Ruby' do
  list:
    Много подходящ за тази цел
    Популярен главно заради <a href="http://rubyonrails.org/">Ruby on Rails</a>
    Има и други начини за писане на уеб с Ruby

= slide 'Как работи?' do
  list:
    Клиент (браузър) → HTTP сървър → Ruby (Rack) → Ruby (App)
    "Ruby (App)" обикновено е вашият код + някаква друга библиотека за уеб (Rails, Sinatra, ...)
    Допустими е и HTTP сървърът да е на Ruby
    Последното се прави обикновено само в development режим
    Какво е Rack?

= slide 'Rack' do
  blockquote
    | Rack provides a minimal, modular and adaptable interface for developing web applications in Ruby. By wrapping HTTP requests and responses in the simplest way possible, it unifies and distills the API for web servers, web frameworks, and software in between (the so-called middleware) into a single method call.
  p.action Rack в GitHub: #{github_repo 'rack/rack'}

= slide 'Примерно Rack-приложение' do
  p Запазете следния код във файл <code>config.ru</code> и пуснете с <code>rackup config.ru</code>
  example:
    hello_world_app = proc do |env|
      [200, {'Content-Type'   => 'text/plain'}, ['Hello, World!']]
    end

    run hello_world_app

= slide 'Вход' do
  list:
    За вход вашето Rack-приложение приема единствен аргумент - `env`
    Той съдържа хеш с всичката ви необходима информация, за да отговорите
    Cookies, информация за клиента (браузъра), налични сесии, информация за сървъра...

= slide 'Вход', 'нека го инспектираме' do
  example:
    dump_env = proc do |env|
      body = env.map { |key, value| "#{key}: #{value}" }.join("\n")
      [200, {'Content-Type'   => 'text/plain'}, [body]]
    end

    run dump_env

= slide 'Вход' do
  pre
    |
      SERVER_SOFTWARE: thin 1.3.1 codename Triple Espresso
      SERVER_NAME: localhost
      rack.input: #&lt;Rack::Lint::InputWrapper:0x007fbe7b8484b0&gt;
      rack.version: [1, 0]
      rack.errors: #&lt;Rack::Lint::ErrorWrapper:0x007fbe7b848438&gt;
      rack.multithread: false
      rack.multiprocess: false
      rack.run_once: false
      REQUEST_METHOD: GET
      REQUEST_PATH: /
      PATH_INFO: /
      REQUEST_URI: /
      HTTP_VERSION: HTTP/1.1
      HTTP_HOST: localhost:9292
      HTTP_CONNECTION: keep-alive
      HTTP_CACHE_CONTROL: max-age=0
      HTTP_USER_AGENT: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_5) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.95 Safari/537.11
      HTTP_ACCEPT: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
      HTTP_ACCEPT_ENCODING: gzip,deflate,sdch
      HTTP_ACCEPT_LANGUAGE: en-US,en;q=0.8
      HTTP_ACCEPT_CHARSET: ISO-8859-1,utf-8;q=0.7,*;q=0.3
      GATEWAY_INTERFACE: CGI/1.2
      SERVER_PORT: 9292
      QUERY_STRING: 
      SERVER_PROTOCOL: HTTP/1.1
      rack.url_scheme: http
      SCRIPT_NAME: 
      REMOTE_ADDR: 127.0.0.1
      async.callback: #&lt;Method: Thin::Connection#post_process&gt;
      async.close: #&lt;EventMachine::DefaultDeferrable:0x007fbe7b8443b0&gt;

= slide 'Изход' do
  list:
    Трябва да върнете списък с три елемента:
    `[http_status_code, headers, content]`
    `http_status_code` е число, по HTTP спецификацията (напр. 200 или 404)
    `headers` е хеш с HTTP хедъри
    `content` е нещо, което трябва да отговаря на `each` и да връща парчета данни

= slide 'The Rack lobster' do
  list:
    Малко примерно Rack приложение
    Свалете <a href="14/lobster.rb" target="_blank">lobster.rb</a> и <a href="14/lobster.ru" target="_blank">lobster.ru</a>
    Пуснете го с `rackup lobster.ru`
    Отворете <a href="http://localhost:9292/" target="_blank">localhost:9292</a>

= slide 'Rack-посредници', '= Rack middleware' do
  list:
    Rack философията е базирана на т. нар. middleware
    Middleware може е всеки Rack app
    Образува се верига от вложени един в друг middleware компоненти
    Който е най-отпред, е с най-висок "приоритет"
    Request-ът минава през всеки по веригата
    Всеки може да реши дали да извика следващия по веригата, или направо да върне резултат
    Вкарвате ги с `use SomeMiddleware`

= slide 'Rack-посредници', 'примери' do
  list:
    `Rack::Runtime` добавя `X-Runtime` хедър
    `Rack::ShowExceptions`
    `Rack::ShowStatus`
    `Rack::Sendfile`
    `Rack::Logger`
    `Rack::Lock`
    `Rack::ETag`, `Rack::ContentLength`, `Rack::Chunked`...
    <a href="https://github.com/rack/rack/blob/master/lib/rack">Още много...</a>

= slide 'Поддържани уеб сървъри' do
  pre
    |
      Mongrel               Ebb
      EventedMongrel        Fuzed
      SwiftipliedMongrel    Glassfish v3
      <strong>WEBrick</strong>               <strong>Phusion Passenger</strong>
      FCGI                  <strong>Puma</strong>
      CGI                   Rainbows!
      SCGI                  <strong>Unicorn</strong>
      LiteSpeed             unixrack
      <strong>Thin</strong>                  Zbatery

= slide 'Поддържани уеб библиотеки' do
  pre
    |
      Ruby on Rails   Coset
      Padrino         Halcyon
      Sinatra         Mack
      Sin             Maveric
      Vintage         Merb
      Waves           Camping
      Wee             Ramaze

  p …и много други.

= slide 'Deployment на production' do
  list:
    Пред HTTP-сървъра, интегриран с Rack, обиновено има и друг HTTP сървър/прокси
    Например Nginx, Apache или някое HTTP прокси
    Горните са много добри в сервиране на статично съдържание
    Помагат и за load-balancing
    Обикновено има и няколко Ruby-процеса, които са заредили Rack-приложения и обработват заявки
    "Application server" модел - кодът стои зареден в паметта

= slide 'В development режим' do
  list:
    В режим на разработка обикновено се ползва само един Rack-supported HTTP съръвр
    За простота понякога дори и WEBrick
    Още thin/mongrel/passenger
    Имплементирани са различни схеми за автоматично презареждане на файлове при промяна
    Горното се налага заради "application server" модела

= slide 'Ruby (App)', 'или къде обикновено пишем нашия уеб код' do
  list:
    Клиент (браузър) → HTTP сървър → Ruby (Rack) → Ruby (App)
    Където Ruby (App) може да бъде:
    Голо Rack приложение (видяхме примери за това)
    Sinatra приложение
    Padrino приложение
    Ruby on Rails приложение
    И прочее...

= slide 'Sinatra' do
  blockquote
    |
      Sinatra is a domain-specific language for building websites, web services, and web applications in Ruby. It emphasizes a minimalistic approach to development, offering only what is essential to handle HTTP requests and deliver responses to clients.
  p — Из "Sinatra Up and Running"

= slide 'Sinatra' do
  list:
    DSL + API, удобни за писане на (по-прости) уеб приложения
    Основно ядро < 2 KLOC Ruby
    Тънък слой над Rack
    Lightweight

= slide 'Sinatra', 'не е фреймуърк' do
  list:
    Не ви налага почти нищо
    Няма вградено ORM
    Няма файлова структура по подразбиране
    Няма дифолтни конфигурационни файлове, генератори или подобни

= slide 'Sinatra vs. Padrino vs. Rails' do
  list:
    Sinatra - не е фреймуърк
    Padrino - мини фреймуърк (има ORM, структура на файловете)
    Rails - мастодонт; има мнение за почти всичко; The Rails Way™
    The right tool for the right job

= slide 'Обратно към Sinatra', 'инсталация' do
  list:
    Разпространява се като Ruby gem, подобно на другите
    `gem install sinatra`
    `require 'sinatra'` и сте в играта
    Опционално, може да сложите и Thin (`gem install thin`)
    Sinatra ще ползва него вместо WEBrick, ако го има

= slide 'Модели на разработка' do
  list:
    Два модела на разработка:
    Класически
    Модулен (modular)

= slide 'Класически модел' do
  list:
    DSL-ът е миксиран в Object
    Максимум един app в рамките на Ruby процес
    Бърз и удобен
    Не се счита за лоша практика да го ползвате
    Получавате него като направите `require 'sinatra'`

= slide 'Модулен модел' do
  list:
    Ползвате само `require 'sinatra/base'`
    Правите клас, наследяващ от `Sinatra::Base`
    DSL-ът не се миксира в Object
    Ако имате малко по-сложни проекти
    Ако искате да имате повече от един Sinatra app в рамките на един Ruby процес
    Ако правите gem/библиотека, която съръжа Sinatra приложение за вграждане другаде

= slide 'Hello, World!', 'пример в класически стил' do
  example:
    require 'sinatra'

    get '/' do
      'Booyah!'
    end

  p Пускате с <code>ruby booyah.rb</code> и тествате, например с <code>telnet</code>
  p Какво става, ако поискаме несъществуващ адрес?

= slide 'Грешки: 404' do
  img src="14/404.png" style="max-width: 90%; max-height: 70%;"

= slide 'Грешки' do
  list:
    Sinatra се грижи да прихване 404 и 500
    500 = Internal Server Error
    За последното получаваме и удобен backtrace

= slide 'Маршрути (routes)' do
  list:
    DSL-ът на Sinatra е тясно свързан с т. нар. HTTP verbs
    Поддържани: `GET`, `POST`, `PUT`, `DELETE`, `PATCH`, `HEAD`, `OPTIONS`
    Indempotence: `GET`, `HEAD`, `PUT`, `DELETE`
    Един маршрут: HTTP verb + URL path
    Следователно, `get '/'` != `post '/'`

= slide 'Параметри' do
  list:
    Може да ги достъпвате в тялото на даден маршрут през `params[:param_name]`
    Имате достъп до три вида параметри там:
    URL параметри
    Query string параметри
    Параметри от тялото на post-заявка

= slide 'Параметри в URL-а' do
  example:
    get '/greet/:name' do
      "Hey there, #{params[:name]}!"
    end

= slide 'Wildcard маршрути и приоритет' do
  list:
    Може да ползвате `*` в дефиниця на маршрут
    Това е greedy
    Ще е достъпно през `params[:splat]`
    Оценката на маршрутите спира след "първото достатъчно съвпадение"
    Приоритетът е отгоре надолу, т.е. в реда, в който сте ги дефинирали

= slide 'Камък, ножица, хартия', 'малко по-голям пример' do
  list:
    Сваляте <a href="14/game.rb" target="_blank">game.rb</a>
    Пускате с `ruby game.rb`
    Играете на <a href="http://localhost:4567/play/paper">localhost:4567/play/some_move</a>

= slide 'Камък, ножица, хартия (2)' do
  example:
    require 'sinatra'

    before do
      content_type :txt
      @moves = {rock: :scissors, paper: :rock, scissors: :paper}
    end

    get '/play/:move' do
      # Игрова логика
    end

= slide 'Камък, ножица, хартия (3)' do
  example:
    get '/play/:move' do
      # Внимавайте с #to_sym на произволни низове!
      player_move = params[:move].to_sym

      unless @moves.has_key?(player_move)
        valid_moves = @moves.keys.map(&:to_s).join(', ')
        halt 403, "You must throw one of the following: #{valid_moves}"
      end
    end

= slide 'Камък, ножица, хартия (4)' do
  example:
    get '/play/:move' do
      # Проверка за валиден ход...

      computer_move = @moves.keys.sample

      if player_move == computer_move
        "Oh, my!\nIt's a tie!"
      elsif computer_move == @moves[player_move]
        "Nicely done, #{player_move} beats #{computer_move}!"
      else
        "Ouch... You got trashed, #{computer_move} beats #{player_move}. Better luck next time!"
      end
    end

= slide '' do
  list:
    TODO

= slide '' do
  list:
    TODO

= slide '' do
  list:
    TODO

= slide '' do
  list:
    TODO

= slide '' do
  list:
    TODO

= slide '' do
  list:
    TODO

= slide '' do
  list:
    TODO

= slide 'sinatra-contrib' do
  blockquote Collection of common Sinatra extensions, semi-officially supported.
  p GitHub repo: #{github_repo 'sinatra/sinatra-contrib'}

= slide 'Повече информация' do
  list:
    Книгата "Sinatra Up and Running" на O'Reilly
    (Тя е за Sinatra 1.3.0, в момента latest stable е 1.3.3, dev branch 1.4.0)
    Кодът на самия <a href="https://github.com/sinatra/sinatra">проект в GitHub</a>

