= slide 'Днес' do
  list:
    Интроспекция в Ruby
    Изключения

= slide 'Интроспекция' do
  list:
    Начин програмно да инспектирате свойства на код
    Още: рефлекция (reflection)
    Необходимост, за да може да се метапрограмира на даден език

= slide 'Интроспекция на ОО йерархията' do
  list:
    Най-простата форма на интроспекциящ
    Много от тези методи вече сте ги виждали в действие или поне сте чували за тях:
    `class` ви дава класа на даден обект; всеки обект има клас, дори класовете
    `superclass` - родителският клас
    `kind_of?` (със синоним `is_a?`)
    `instance_of?`
    `ancestors` - списъкът от класове и модули, в който се търси метод при извикване на такъв

= slide 'Разглеждане на обекти', 'методите им' do
  list:
    `methods` - списък с методите, на които отговаря дадена инстанция
    Забележете, че `foo.methods != foo.class.methods`
    Горното е следствие на факта, че и класовете са инстанции и си имат собствени методи
    Например:

  .action
    annotate:
      'foo'.methods.size  # =>
      String.methods.size # =>

= slide 'Разглеждане на обекти', 'Методите им' do
  list:
    Може да видите какви методи дефинира даден клас за своите инстанции
    Следните имена са очевидни:
    `private_instance_methods`
    `protected_instance_methods`
    `public_instance_methods`
    `singleton_methods` ви връша класовите методи

= slide 'Методи на обекти', 'Пример' do
  example:
    class Ruby
      def self.author; 'Matz'; end

      def version; '1.9.3'; end
      def repository; 'Git'; end
      def implementation; 'MRI C'; end

      protected :repository
      private :implementation
    end

    Ruby.public_instance_methods     # =>
    Ruby.protected_instance_methods  # =>
    Ruby.private_instance_methods    # =>
    Ruby.singleton_methods           # =>

= slide 'Методи на обекти' do
  list:
    Културната проверка дали даден обект има определен метод:
    `object.respond_to?(method_name)`
    Ще върне `true`, ако можете безопасно да изпълните `object.x`
    Тук е подходящо да подадете символ като `method_name`
    Връща `false` и за `private` и `protected` методи
    Ако му подадете `true` като втори аргумент, ще игнорира видимостта на метода

= slide 'Инстанционни променливи' do
  list:
    Можете да инспектирате и манипулирате инстанционни променливи на обекти с тези методи:
    `instance_variable_get`
    `instance_variable_set`
    `instance_variable_defined?`
    `remove_instance_variable` - този метод е `private`
    Забележете, че трябва да включите и `@` в името на променливата

= slide 'Инстанционни променливи', 'Пример' do
  annotate:
    class Foo
      def initialize
        @baba = 42
      end

      def touch
        @touched = true
      end
    end

    foo = Foo.new

    foo.instance_variables # =>
    foo.touch
    foo.instance_variables # =>

= slide 'Инстанционни променливи', 'Пример' do
  annotate:
    class Foo
      def initialize
        @baba = 42
      end
    end

    foo = Foo.new

    foo.instance_variable_defined? :@baba # =>

    foo.send(:remove_instance_variable, :@baba)
    foo.instance_variable_defined? :@baba # =>

= slide 'Константи' do
  list:
    Имената на класове и модули са константи
    Константи могат да бъдат дефинирани в класове и модули
    Top-level константите отиват в `Object`
    Съществуват методи за интроспекция и манипулирание на константи

= slide 'Константи' do
  list:
    Методите за интроспекция на константи идват от `Module` (`Class < Module`)
    `constants` връща списък с константите, дефинирани в дадения клас/модул
    `const_get` ви връща стойността на дадена константа
    `Object.const_get('String').new` е интересен начин да запишете `''`
    `const_set` ви дава възможност да създадете (или промените) константа в класа/модула
    `const_defined?` - проверка дали дадена константа съществува в класа/модула
    `remove_const` - премахва константа от клас/модул

= slide 'Константи' do
  annotate:
    Regexp.constants          # =>
    Object.constants.take(5)  # =>
    Object.constants.size     # =>

  list:
    `Object.constants` е списък на всички top-level константи, дефинирани към момента

= slide 'Константи', 'не правете така' do
  example:
    String # String
    Object.const_set(:String, Fixnum)
    String # Fixnum



= slide 'Object#method(method_name)' do
  list:
    Позволява ви да вземете референция към метод на даден обект
    Връща обект от тип `Method`
    Ако такъв метод няма, хвърля изключение (`NameError`)
    Инстанциите на `Method` се държат като closure

  .action
    annotate:
      class Person
        def name
          'Matz'
        end
      end

      Person.new.method(:name) # =>

= slide 'Класът Method', 'Или какво може да правите с обектите му' do
  list:
    Интерфейсът му донякъде наподобява анонимни функции и proc-ове, с малко екстри
    `call` ще извика въпросния метод
    `name` ще ви даде името на метода
    `owner` - класът или модулът, откъдето е дошъл този метод
    `receiver` - обектът получател на този метод (инстанцията, обвързана с метода)
    `arity` връща колко аргумента приема метода (с врътки за променлив брой аргументи)
    `parameters` - детайлна информация за приеманите аргументи - имена, дали са задължителни и т.н.
    `source_location` - в кой файл и на кой ред е дефиниран този метод; много полезно
    `unbind` - "разкача" този метод от получателя му; връща ви инстанция на `UnboundMethod`

= slide 'Method#call' do
  annotate:
    class Person
      attr_accessor :name
    end

    someone = Person.new
    someone.name = 'Murakami Haruki'

    name_method = someone.method(:name)
    name_method.call  # =>

= slide 'Method#arity и #parameters' do
  annotate:
    def foo(x, y, z); end

    method(:foo).arity      # =>
    method(:foo).parameters # =>

    def bar(x, y, z = 1); end

    method(:bar).arity      # =>
    method(:bar).parameters # =>

= slide 'Proc#arity' do
  list:
    Подобно на `call`, и `Proc`-обектите имат метод `ariry` със същото действие
    Това важи за анонимни функции, блокове и всякакви инстанции на `Proc`
    Например:

  .action
    annotate:
      Proc.new { |x| }.arity      # =>
      lambda { |x, y| }.arity     # =>

= slide 'Method#source_location' do
  list:
    Работи само за методи, дефинирани на Ruby
    Полезно при дебъг на непознат код (вкл. и такъв, идващ от gem-ове)
    Връща списък с два елемента - път до Ruby файл и ред в този файл

  .action
    annotate:
      require 'set'
      Set.new.method(:to_a).source_location # ["/Users/.../ruby-1.9.3/lib/ruby/1.9.1/set.rb", 144]

      class Set; def to_a; super; end; end
      Set.new.method(:to_a).source_location # =>

= slide 'Необвързани методи' do
  list:
    Инстанции на `UnboundMethod`
    Имат почти същите методи като и обвързаните (т.е. инстанциите на `Method`)
    Не могат да бъдат извиквани
    Mогат да бъдат обвързани впоследствие към други инстанции

= slide 'Необвързани методи' do
  annotate:
    class Person
      attr_reader :name

      def initialize(name)
        @name = name
      end
    end

    stefan = Person.new 'Stefan'
    mitio  = Person.new 'Mitio'

    stefan.name                           # =>

    stefans_name = stefan.method(:name)
    stefans_name.call                     # =>
    stefans_name.unbind.bind(mitio).call  # =>


= slide 'Човъркане с виртуалната машина' do
  list:
    Да спрем събирането на боклука
    Класът `GC` - интерфейс към mark-and-sweep garbage collector-а на Ruby
    `GC.stop` спира събирането на неизползвани обекти

  .action
    annotate:
      GC.methods - Object.methods # =>
      GC.constants                # =>

= slide 'GC::Profiler', 'Профилиране на garbage collector-а' do
  example:
    GC::Profiler.enable
    require 'active_support/ordered_hash'
    puts GC::Profiler.result

  .action
    p Резултати:
    pre
      | GC 8 invokes.
        Index    Invoke Time(sec)       Use Size(byte)     Total Size(byte)         Total Object                    GC Time(ms)
            1               0.706              2889840             16818080               420452        23.71699999999998809130


= slide 'Интроспекция', 'още reflection' do
  list:
    Kernel
      global_variables
      local_variables
      block_given?

    defined?
      defined? 1             # =>
      defined? foo           # =>
      defined? puts          # =>
      defined? String        # =>
      defined? $&            # =>
      defined? $_            # =>
      defined? Math::PI      # =>
      defined? answer = 42   # =>
      defined? 42.abs        # =>

    ObjectSpace
      each_object
        всичко без Fixnum, true, false, and nil.
        ObjectSpace.each_object(Class) { |x| puts x} - класове
      `inspect` -> _id2ref

      define_finalizer(object, proc) - като деструктор
        example:
          foo = 'Memory is plentiful!'
          ObjectSpace.define_finalizer foo, proc { puts 'foo is gone' }
          ObjectSpace.garbage_collect

          foo = nil
          ObjectSpace.garbage_collect # Prints "foo is gone"

    Hooks

      Adding an instance method Module#method_added
        #method_removed
      Adding a singleton method Kernel::singleton_method_added
      Subclassing a class Class#inherited
      Mixing in a module  Module#extend_object
      included

    Kernel#set_trace_func(proc)

      Задава въпросния Proc обкект като трасираща функция
      Параметри: име на събитие, файл, ред, object_id, binding, клас
      Събития:
        `c-call` - извикване на C-метод
        `c-return` - връщане от C-метод
        `call` - извикване на Ruby метод
        `return` - връщане от Ruby метод
        `class` начало на дефиниция на клас или модул
        `end` край на горната дефиниця
        `line` изпълняване на код на ред Х
        `raise` изключение

    example:
      tracer = proc do |event, file, line, id, binding, classname|
         printf "%8s %s:%-2d %15s %15s\n", event, file, line, id, classname
      end

      set_trace_func tracer

      class Foo
        def bar
          a, b = 1, 2
        end
      end

      larodi = Foo.new
      larodi.bar

    pre
      |
        c-return t.rb:5   set_trace_func          Kernel
            line t.rb:7
          c-call t.rb:7        inherited           Class
        c-return t.rb:7        inherited           Class
           class t.rb:7
            line t.rb:8
          c-call t.rb:8     method_added          Module
        c-return t.rb:8     method_added          Module
             end t.rb:11
            line t.rb:13
          c-call t.rb:13             new           Class
          c-call t.rb:13      initialize     BasicObject
        c-return t.rb:13      initialize     BasicObject
        c-return t.rb:13             new           Class
            line t.rb:14
            call t.rb:8              bar             Foo
            line t.rb:9              bar             Foo
          return t.rb:10             bar             Foo

    Kernel#trace_var

    example:
      trace_var :$_, proc { |value| puts "$_ is now #{value.inspect}" }
      $_ = "Ruby"
      $_ = ' > Python'

    p Извежда следното:

    pre
      $_ is now "Ruby"
      $_ is now " > Python"


