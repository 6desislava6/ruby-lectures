= slide 'Днес' do
  list:
    Информация за проектите, каква тема да изберете и как да я опишете
    The Ten Commandments of Egoless Programming
    Решение на седмо предизвикателство
    `next`, `break`, `redo`, `retry`
    Клас-променливи
    Писане на документация с RDoc
    Ruby Core: `Struct`, `Comparable`, `Marshal`, `IO` & `File`
    `RubyVM::InstructionSequence`
    Ruby Stdlib: `OpenStruct`

= slide 'Проекти' do
  list:
    Крайният срок да си изберете тема и <strong>да ви я одобрим</strong>, е <strong>24.12.2014</strong>, 23:59:59
    Идеята не е толкова важна
    Важно е да прекарате време с Ruby и екосистемата около него и да напишете нещо по-голямо
    Имаме [ръководство за проектите](https://github.com/fmi/ruby-course-guides/blob/master/course_projects.md#readme), което ще допълваме
    Най-важното нещо за проектите - ще ви трябва време и трябва да започнете рано - още тази година :)

= slide 'Какво очакваме да ни изпратите?', 'или, как да напишете спецификация' do
  list:
    Пак - темата е почти без значение
    Имаме нужда да придобием представа единствено дали проектът ви ще е достатъчно (и не прекалено) голям и сложен
    Ако не получите никакъв отговор от нас в рамките на 4-5 дни, пишете ни пак или пробвайте друг комуникационен канал

= slide 'Лоши примери (1)' do
  list:
    "Идеята ми за проект е система за управление на магазин"
    Какви технологии?
    Уеб, command-line, GUI?
    Бази данни ще има ли?
    Какви интерфейси?
    Роли? Автентикация, авторизация?
    Груби спецификации за това какви данни ще се пазят и какви операции ще могат да се извършват?

= slide 'Лоши примери (2)' do
  list:
    "Избрах си тема за проект - играта Battleships"
    Двама играча ще се редуват на един компютър, или ще се играе срещу компютъра?
    Ще се играе ли по мрежа, или само локално, на една машина?
    Кои ще са двата интерфейса? Command-line? Gosu? Друго?
    Горното е твърде просто - има нужда от "усложнения"; например - save/restore на текущата игра

= slide 'Лоши примери' do
  list:
    Представете си, че клиент дойде при вас и ви каже само това едно изречение и след това попита "Колко ще струва?"
    Не е нужно да сте безкрайно подробни, но се постарайте да засегнете темите и технологиите, които ще използвате
    Важно е да се получи ориентир за сложността и да се съгласим за базова функционалност-минимум

= slide '(Не)подходящи теми', 'или, къде Ruby е силен и къде - не' do
  list:
    Ruby е general-purpose език, но не е удачно решение за някои проблеми, като:
    Тежки, алгоритмични и изчислителни проблеми, които са CPU-bound, изискват CPU-паралелизация и/или garbage collection-ът ще им пречи
    Десктоп приложения с бутончета, менюта и прочее
    Тежки и големи игри
    Мобилни приложения (но пък има RubyMotion)
    Embedded системи (но за това пък има [mruby](http://mruby.org))
    Приложения, чиято основна работа е да имплементират дадено API - окей е за Ruby, но е неподходящо като тема

= slide '(Не)подходящи теми', 'изключения' do
  list:
    Ако не сте студент във ФМИ, или оценката и точките не ви интересуват, може да пробвате и Rails
    На защитата ще ви дадем обратна връзка за това
    Може да пишете и десктоп приложения, като ползвате Shoes (новата версия) или Tkinter (Tk) - не е особено практично, но е окей за курсов проект
    В случая на десктоп приложение, ще искаме да имате и някакъв алтернативен интерфейс към функционалността (например, command-line)
    По-прости, 2D-игри, с помощта на [Gosu](http://www.libgosu.org/) - пак искаме втори интерфейс (например, command-line)

= slide 'The Ten Commandments of Egoless Programming' do
  ul
    li Стари, но добри
    li Заслужават си и са добър начин за начало на новата година
    li Може да ги видите в <a href="http://www.codinghorror.com/blog/2006/05/the-ten-commandments-of-egoless-programming.html">оригиналния контекст тук</a>
    li Нека ги разгледаме

= slide '1. Understand and accept that you will make mistakes.' do
  blockquote
    |
      The point is to find them early, before they make it into production. Fortunately, except for the few of us developing rocket guidance software at JPL, mistakes are rarely fatal in our industry, so we can, and should, learn, laugh, and move on.

= slide '2. You are not your code.' do
  blockquote
    |
      Remember that the entire point of a review is to find problems, and problems will be found. Don't take it personally when one is uncovered.

= slide '3. No matter how much "karate" you know, someone else will always know more.' do
  blockquote
    |
      Such an individual can teach you some new moves if you ask. Seek and accept input from others, especially when you think it's not needed.

= slide "4. Don't rewrite code without consultation." do
  blockquote
    |
      There's a fine line between "fixing code" and "rewriting code." Know the difference, and pursue stylistic changes within the framework of a code review, not as a lone enforcer.

= slide '5. Treat people who know less than you with respect, deference, and patience.' do
  blockquote
    |
      Nontechnical people who deal with developers on a regular basis almost universally hold the opinion that we are prima donnas at best and crybabies at worst. Don't reinforce this stereotype with anger and impatience.

= slide '6. The only constant in the world is change.' do
  blockquote
    |
      Be open to it and accept it with a smile. Look at each change to your requirements, platform, or tool as a new challenge, not as some serious inconvenience to be fought.

= slide '7. The only true authority stems from knowledge, not from position.' do
  blockquote
    |
      Knowledge engenders authority, and authority engenders respect – so if you want respect in an egoless environment, cultivate knowledge.

= slide '8. Fight for what you believe, but gracefully accept defeat.' do
  blockquote
    |
      Understand that sometimes your ideas will be overruled. Even if you do turn out to be right, don't take revenge or say, "I told you so" more than a few times at most, and don't make your dearly departed idea a martyr or rallying cry.

= slide %(9. Don't be "the guy in the room.") do
  blockquote
    |
      Don't be the guy coding in the dark office emerging only to buy cola. The guy in the room is out of touch, out of sight, and out of control and has no place in an open, collaborative environment.

= slide '10. Critique code instead of people – be kind to the coder, not to the code.' do
  blockquote
    |
      As much as possible, make all of your comments positive and oriented to improving the code. Relate comments to local standards, program specs, increased performance, etc.

= slide 'Малко код за загрявка' do
  list:
    Код, вдъхновен от парче JavaScript, което ми се наложи да напиша неотдавна
    Функция, която за дадено CSS property, връща списък с всички негови префикси
    Въпреки, че надали бихме го написали на Ruby, принципите остават в сила

= slide 'Вариант 1', 'без дублиране на "знание"' do
  example:
    class CSS
      PREFIXES = ['webkit', 'moz', 'ms', 'o']

      def browser_prefixes_for(css_property_name)
        PREFIXES.map do |prefix|
          "-#{prefix}-#{css_property_name}"
        end
      end
    end

= slide 'Вариант 2', 'добавихме стандартния префикс' do
  example:
    class CSS
      PREFIXES = ['webkit', 'moz', 'ms', 'o', nil]

      def browser_prefixes_for(css_property_name)
        PREFIXES.map do |prefix|
          prefix ? "-#{prefix}-#{css_property_name}" : css_property_name
        end
      end
    end

= slide 'Вариант 3', 'като вариант 2, но по-просто' do
  example:
    class CSS
      PREFIXES = ['-webkit-', '-moz-', '-ms-', '-o-', '']

      def browser_prefixes_for(css_property_name)
        PREFIXES.map do |prefix|
          prefix + css_property_name
        end
      end
    end

= slide 'Proc Placeholder' do
  example:
    challenges[6].solutions.size < 7 # true
    challenges[6].solutions.one?(&:correct?) # true

== slide 'Да се дефинира P, такова че...' do
  example:
    (1..5).map(&P ** 2) # [1, 4, 9, 16, 25]
    [[1, 2, 3, 8], [4, 5], [6]].map(&P.select(&:even?)) # [[2, 8], [4], [6]]
    (1..5).map(&P)    # [1, 2, 3, 4, 5]

== slide 'Ще реализираме P като клас и ще дефинираме само класови методи' do
  example:
    class P
      class << self
        # ...
      end
    end

== slide 'P трябва да приема вскякви извиквания на методи...' do
  example:
    class P
      class << self
        def method_missing(method, *args, &block)
          # ...
        end
      end
    end

== slide '...и да ги пренасовча към конкретен обект' do
  example:
    class P
      class << self
        def method_missing(method, *args, &block)
          Proc.new { |object| object.send method, *args, &block }
        end
      end
    end

== slide 'P трябва да се държи като идентитет, ако не е извикан метод' do
  example:
    class P
      class << self
        def method_missing(method, *args, &block)
          Proc.new { |object| object.send method, *args, &block }
        end

        def to_proc
          Proc.new { |object| object }
        end
      end
    end

== slide 'P трябва да се държи като proxy и да прехвърля всеки извикан метод на обектите от колекцията...' do
  example:
    class P < BasicObject
      class << self
        def method_missing(method, *args, &block)
          ::Proc.new { |object| object.send method, *args, &block }
        end

        def to_proc
          ::Proc.new { |object| object }
        end
      end
    end

== slide '...абсолютно всеки метод' do
  example:
    class P < BasicObject
      class << self
        instance_methods.each do |instance_method|
          undef_method instance_method
        end

        def method_missing(method, *args, &block)
          ::Proc.new { |object| object.send method, *args, &block }
        end

        def to_proc
          ::Proc.new { |object| object }
        end
      end
    end

= slide 'Object#eql?' do
  ul
    li <code>#eql?</code> прави сравнение без type coercion.
    li Не забравайте, че се ползва и за хешове.

  annotate:
    1 == 1.0     # =>
    1.eql?(1.0)  # =>

= slide '$! и $@' do
  ul
    li Глобални променливи
    li <code>$!</code> е последното "възбудено" изключение
    li <code>$@</code> е stacktrace-а на последното изключение

= slide 'retry в ensure' do
  p <code>retry</code> изпълнява <code>begin</code> блока отначало.

  example:
    retries_left = 3

    begin
      connect_to_facebook
    rescue ConnectionError
      retries_left -= 1
      retry if retries_left > 0
    end

= slide 'next, break, redo, retry' do
  p Има много хубава семантика за тях.

  table
    thead
      tr
        th
        th излизане от...
        th рестартиране на...
    tbody
      tr
        td ...блока
        td
          code next
        td
          code redo
      tr
        td ...метода
        td
          code break
        td
          code retry

  p <code>retry</code> не работи извън <code>rescue</code> от Ruby 1.9 насам.

= slide 'Клас променливи' do
  annotate:
    class Person
      @@count = 0

      def initialize
        @@count += 1
      end

      def self.how_many
        @@count
      end
    end

    Person.new
    Person.new
    Person.how_many # =>

= slide 'Клас променливи', 'семантиката' do
  list:
    Очевидно започват с `@@`
    Търсят се в обхващащата константа
    Ако я няма там, се търсят в родителя ѝ
    Съответно, достъпни са в инстанция и в клас
    Ако не са дефинирани, получавате `NameError` (направете разлика с инстанционните променливи)
    Работят объркващо, така че по-добре ги избягвайте
    Ако все пак ги ползвате, правете го когато нямате наследяване

= slide 'Клас променливи' do
  annotate:
    class B
      @@foo = 1
      def self.foo() @@foo end
      def self.hmm() @@bar end
    end

    class D < B
      @@bar = 2
      def self.bar() @@bar end
      def self.change() @@foo = 3; @@bar = 4; end
    end

    [B.foo, D.foo, D.bar] # =>
    B.hmm                 #!
    D.change
    [B.foo, D.foo, D.bar] # =>
    B.hmm                 #!
    D.hmm                 #!

= slide 'Class#new и Object#initialize' do
  p Всъщност, <code>#initialize</code> е просто instance метод.

  p <code>Class#new</code> е имплементиран горе-долу така:

  example:
    class Class
      def new
        object = self.allocate
        object.send :initialize
        object
      end
    end

= slide 'Object#dup, Object#clone, #initialize_copy' do
  list:
    `#dup` и `#clone` правят копие на обект
    Копието е "shallow" копие, т.е. ако има instance променливи, те сочат на същото място
    След като се направи, се вика `#initialize_copy`
    Разликата между двете: `#clone` копира singleton методи и freeze-ва обекта, ако е замразен


= slide 'Документация в Ruby' do
  list:
    Пишете ли документация? Как? Къде?
    Както повечето други езици и платформи, и в Ruby има инструменти за автоматично генериране на документация
    RDoc — Ruby documentation
    Seattle.rb проект; дефакто стандарт
    YARD — инструмент, разширяващ RDoc-стандарта

= slide 'RDoc' do
  img src="18/rdoc-default.png"

= slide 'YARD' do
  img src="18/rdoc-yard.png"

= slide 'Други - Rails API документацията' do
  img src="18/rdoc-rails.png"

= slide 'Други - API Dock' do
  img src="18/rdoc-apidock.png"

= slide 'RDoc' do
  list:
    Анализира статично вашата файлова структура, класове, модули, методи
    Извлича коментарите над методи, класове и прочее и ги обработва
    Дори да нямате коментари, пак ще генерира смислена и донякъде полезна документация
    Във въпросните коментари може да използвате специален синтаксис

= slide 'Подробно относно RDoc' do
  list:
    Официална документация относно позволения маркъп (малко трудна за откриване):
    [http://docs.seattlerb.org/rdoc/RDoc/Markup.html](http://docs.seattlerb.org/rdoc/RDoc/Markup.html)
    Обща документация на RDoc:
    [http://docs.seattlerb.org/rdoc/index.html](http://docs.seattlerb.org/rdoc/index.html)

= slide 'Ruby core' do
  list:
    Ядрото на Ruby съдържа неща, които са част от интерпретатора и са винаги заредени и налични
    Друг поглед над това е, че винаги заемат памет и не можете да ги махнете
    Това е и причината немалка част от функционалността да е изведена в т.нар. "стандартна библиотека"
    Там са неща, които се ползват сравнително често, но <em>не винаги</em>
    Разглеждали сме повечето класове от `core`; сега ще видим още няколко интересни класа

= slide 'Struct' do
  list:
    Бърз начин да създавате мини-класове, представляващи колекция от атрибути
    Освен getter-и и setter-и за атрибутите, наподобяват малко на хеш
    [Документация на `Struct`](http://ruby-doc.org/core-2.1.5/Struct.html)

= slide 'Struct', 'пример от документацията' do
  p Виждате, че може да добавите и свои методи там

  annotate:
    Customer = Struct.new(:name, :address) do
      def greeting
        "Hello #{name}!"
      end
    end

    dave = Customer.new('Dave', '123 Main')

    dave.name     # =>
    dave.address  # =>
    dave.greeting # =>

= slide 'Struct' do
  p Обектите от тип <code>Struct</code> приличат на колекции (хешове):

  annotate:
    Customer = Struct.new(:name, :address, :zip)
    john = Customer.new('John Doe', '123 Maple, Anytown NC', 12345)

    john.name      # =>
    john['name']   # =>
    john[:name]    # =>
    john[0]        # =>

    john.length    # =>
    john.each      # =>

= slide 'Приложение на Struct' do
  p Удобно е да се ползва в тестове. За production код – по-рядко.

= slide 'Comparable' do
  list:
    Ползва се, когато имате наредба на инстанциите на вашия клас
    Дефинирате `<=>` и правите `include Comparable`
    Получавате `<`, `<=`, `==`, `>=`, `>` и `between?`

= slide 'Comparable', 'пример' do
  annotate:
    class Money
      include Comparable

      attr :amount, :currency

      def initialize(amount, currency)
        @amount, @currency = amount, currency
      end

      def <=>(money)
        return unless currency == money.currency
        amount <=> money.amount
      end
    end

    Money.new(15, :BGN) < Money.new(30, :BGN) # =>

= slide 'Marshal' do
  list:
    Може да се ползва за сериализиране и десериализиране на Ruby обекти
    Продуцира binary низ
    Проста употреба – `Marshal.load` и `Marshal.dump`
    Някои обекти не могат да бъдат сериализирани
    Може да предефинирате как (какво) да е представянето на ваш клас за сериализация
    За целта дефинирате методи `marshal_dump` и `marshal_load`
    Пълната му документация е [тук](http://ruby-doc.org/core-2.1.5/Marshal.html)

= slide 'Marshal', 'пример' do
  annotate:
    data = [42, :answer, {foo: 'bar'}]

    serizlized = Marshal.dump data

    serizlized                       # =>
    Marshal.load(serizlized) == data # =>
    Marshal.load(serizlized)         # =>

= slide 'Marshal', 'употреба и бележки' do
  list:
    Привидно удобен за употреба
    Съображения за сигурност при зареждане на серизлизирани данни "отвън"
    Може да доведе до изпълнение на произволен код
    За алтернатива на `Marshal` може да се ползва `YAML`, от стандартната библиотека
    YAML продуцира "човешки-четим" формат, но носи същите рискове за сигурността

= slide 'IO и File' do
  list:
    Все още не сме говорили за работа с файлове в Ruby
    Употребата е тривиална; достатъчно ви е да разгледате документацията на [`File`](http://ruby-doc.org/core-2.1.5/File.html) и [`IO`](http://ruby-doc.org/core-2.1.5/IO.html)
    `IO` е родителят на файл и представлява входно-изходен поток от данни
    Други класове, наследяващи от `IO` са `TCPSocket` и `UDPSocket`
    Много от методите на `File` идват от `IO`

= slide 'File - два примера' do
  p Прочитане на цял файл като низ:
  example:
    File.read('/etc/resolv.conf') # => "The contents of the file as a string."

  p Отваряне на файл, работа с обекта и автоматично затваряне на файла при излизане от блока:
  example:
    File.open('foo/bar.txt', 'w') do |file|
      file.write 'Some data.'
      file.puts  'Some other data, with a newline at the end.'
      file.puts  'File will be closed automatically, even in case of an exception in the block.'
    end

= slide 'RubyVM::InstructionSequence' do
  list:
    Не толкова полезен, колкото забавен клас
    Дава поглед към начина, по който парче Ruby код изглежда, компилиран в Ruby bytecode
    Специфичен за MRI (CRuby), може да го няма в други имплементации като JRuby, Rubinius и прочее
    [Документаця](http://ruby-doc.org/core-2.1.0/RubyVM/InstructionSequence.html)

= slide 'RubyVM::InstructionSequence', 'пример' do
  example:
    code = 'puts ["a" * 10].first'
    compiled = RubyVM::InstructionSequence.compile(code)
    puts compiled.disasm

  p Резултат:
  pre
    |
      == disasm: &lt;RubyVM::InstructionSequence:&lt;compiled>@&lt;compiled>>==========
      0000 trace            1                                               (   1)
      0002 putself
      0003 putstring        "a"
      0005 putobject        10
      0007 opt_mult         &lt;callinfo!mid:*, argc:1, ARGS_SKIP>
      0009 newarray         1
      0011 opt_send_simple  &lt;callinfo!mid:first, argc:0, ARGS_SKIP>
      0013 opt_send_simple  &lt;callinfo!mid:puts, argc:1, FCALL|ARGS_SKIP>
      0015 leave

= slide 'RubyVM::InstructionSequence', 'още един пример' do
  example:
    puts RubyVM::InstructionSequence.compile('a, b = 1, 2').disasm

  p Можем да видим, че <code>a, b = 1, 2</code> минава през създаване на един обект тип <code>Array</code>:
  pre
    |
      == disasm: &lt;RubyVM::InstructionSequence:&lt;compiled>@&lt;compiled>>==========
      local table (size: 3, argc: 0 [opts: 0, rest: -1, post: 0, block: -1, keyword: 0@4] s1)
      [ 3] a          [ 2] b
      0000 trace            1                                               (   1)
      0002 duparray         [1, 2]
      0004 dup
      0005 expandarray      2, 0
      0008 setlocal_OP__WC__0 3
      0010 setlocal_OP__WC__0 2
      0012 leave

= slide 'Стандартната библиотека на Ruby' do
  list:
    Мислете за нея като за една купчина съвсем обикновени gem-ове, които вървят пакетирани с Ruby
    Част от нея е написана на C, друга част – на Ruby
    В [документацията на stdlib](http://ruby-doc.org/stdlib-2.1.0/) може да видите списъка с "gem"-ове
    За да ползвате нещо от нея, трябва да направите `require 'somelib'`, например `require 'bigdecimal'`
    Множество дребни и интересни библиотеки - разгледайте ги, за да знаете какво имате наготово

= slide 'Налични библиотеки' do
  pre
    |
      abbrev       base64          benchmark    bigdecimal          cgi            cmath
      coverage     csv             curses       date                dbm            debug
      delegate     digest          dl           drb                 e2mmap         English
      erb          etc             extmk        fcntl               fiddle         fileutils
      find         forwardable     gdbm         getoptlong          gserver        io/console
      io/nonblock  io/wait         ipaddr       irb                 json           logger
      mathn        matrix          minitest     minitest/benchmark  minitest/spec  mkmf
      monitor      mutex_m         net/ftp      net/http            net/imap       net/pop
      net/smtp     net/telnet      nkf          objspace            observer       open-uri
      open3        openssl         optparse     ostruct             pathname       pp
      prettyprint  prime           profile      profiler            pstore         psych
      pty          racc            racc/parser  rake                rdoc           readline
      resolv       resolv-replace  rexml        rinda               ripper         rss
      rubygems     scanf           sdbm         securerandom        set            shell
      shellwords   singleton       socket       stringio            strscan        sync
      syslog       tempfile        test/unit    thread              thwait         time
      timeout      tk              tmpdir       tracer              tsort          un
      uri          weakref         webrick      win32ole            xmlrpc         yaml
      zlib

= slide 'Какво сме ползвали досега от Stdlib?' do
  list:
    bigdecimal
    benchmark
    minitest
    И много, много други, пряко и непряко...

= slide 'OpenStruct' do
  list:
    Ще разгледаме само един пример от Stdlib - `OpenStruct`
    Наподобява хеш, но дава достъп до полетата си през методи
    Получавате го, като направите `require 'ostruct'`
    Имплементиран на Ruby, може да разгледате кода
    Дефинира `marshal_load` и `marshal_dump`, може да видите как за пример
    Имплементира и част от интерфейса на `Hash`, като `each_pair` и методите `[]` и `[]=`
    Вижте цялата му [документация](http://ruby-doc.org/stdlib-2.1.0/libdoc/ostruct/rdoc/OpenStruct.html)

= slide 'OpenStruct - пример' do
  annotate:
    require 'ostruct'

    john = OpenStruct.new
    john.name = 'John Doe'
    john.age  = 33

    john.name     # =>
    john.age      # =>
    john.address  # =>
