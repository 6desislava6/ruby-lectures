= slide 'Идната седмица' do
  list:
    Ще разгледаме добри и лоши решения от последните предизвикателства и задачи
    Това включва и [днешното предизвикателство](/challenges/10)
    Ще направим първия тест

= slide 'Първи тест' do
  list:
    [Сряда, 4 декември](http://doodle.com/twn8hwcuccqxdvzs), по време на лекции (19:00 - 21:00 ч., зала 200)
    30 въпроса, 45 минути
    Разделени сте на две групи – четните факултетни номера от 19:00, нечетните – от 20:15 ч.
    Напомняме, че има два теста, носят по 30 точки всеки
    Вторият тест ще е в края на семестъра и/или по време на сесията

= slide 'Днес' do
  list:
    Ще се забавляваме с регулярни изрази (очевидно)
    Регулярните изрази в бита на програмиста
    Регулярните изрази в Ruby (2.1.0)
    Как да ги ползваме в Ruby код

= slide 'Stand back...' do
  a href="http://xkcd.com/208/"
    img src="12/regular_expressions.png"
    p style="text-align: center;"
      small
        em Wait, forgot to escape a space. Wheeeeee[taptaptap]eeeeee.

= slide 'Знам регулярни изрази!', 'За просветените в тайнството...' do
  list:
    Чували сте за регулярни изрази?
    Чувствате се умели в употребата им?
    Страхувате се, че ще ви е скучно днес?
    Ето ви дребни задачки, за да не ви е скучно

= slide 'Традиционната задача', 'за тези от вас, които се чувстват комфортно с РИ' do
  p Имаме следната задача:
  blockquote
    | Да се напише кратък Ruby expression, който проверява дали дадено число е просто или не,
      посредством употреба на регулярен израз. Резултатът от изпълнението му трябва да е <code>true</code>
      за прости числа и <code>false</code> за всички останали. Неща, които можете да ползвате:
    list:
      Самото число, разбира се.
      Произволни методи от класа `Regexp`
      Подходящ регулярен израз (шаблон)
      Текстовия низ `'1'`.
      `String#*`.
      Някакъв условен оператор (например `if`-`else` или `? … : …`)
      `true`, `false`, ...
  list:
    Материалът, необходим за решаването й, ще го има изцяло в днешната лекция.

= slide 'И още една задача', 'за тези от вас, които вече ни знаят номерата' do
  p Имаме следната задача:
  blockquote
    | Да валидирате изрази от следния тип за правилно отворени/затворени скоби:
    list:
      `(car (car (car ...)))`
      Например: `(car (car (car (car list))))`
      Целта е израз, чийто резултат да може да се ползва в условен оператор (`true`/`false`-еквивалент)
      Можете да ползвате произволни методи от класа `Regexp`
      И регулярен израз, разбира се
  list:
    Ще обсъдим възможните решения и на двете задачи по-късно в рамките на днешната сбирка.

= slide 'Disclaimer' do
  blockquote
    em Some people, when confronted with a problem, think "I know, I'll use regular expressions." Now they have two problems.

= slide 'Една забавна история', '...за ножове с много остриета' do
  list:
    Имахме доста забавно преживяване с бъг в сайта на курса преди месец-два
    Интересна история за дебъгване, която ще ви разкажа накратко сега

= slide 'Симптомите и първи стъпки на дебъгване' do
  list:
    Сайтът "пада" (спира да отговаря на заявки)
    Много Ruby процеси, изяли цялото налично CPU, сайтът не отговаря дори за статични файлове
    DDoS? Логовете не показват много трафик
    Стар софтуер? Apache 2.2.16 при нас, 2.2.26 най-нова в клона 2.2.х, а най-новата изобщо - 2.4.7
    Забутан бъг във взаимодействието м/у Apache, Passenger и т.н.?
    `strace` -- плюсове и минуси
    Phusion Passenger и `SIGABRT`

= slide 'Причината' do
  list:
    Оказа се, че в логовете се виждат започнали, но незавършили заявки за следния URL:
    [http://fmi.py-bg.net/topics/525?page=2](http://2013.fmi.py-bg.net/topics/525?page=2)
    Това е тема за задача за "Змия" от курса по Пайтън, който се движи от същия код
    На втората страница в тази тема, има следния блок с код (извадка от темата):

= slide 'Причината (2)' do
  p Текстуално илюстриране на света и змията:

  pre
    |
      ..................................................
      ..................................................
      ..................##@@............................
      ..................##..............................
      ..................######..........................
      ..................................................
      ..................................................

= slide 'Виновникът' do
  list:
    Сайтът на курса ползва библиотеката `rails_autolink`
    Автоматично прави URL-и и имейли на линкове в текстовете на вашите коментари и публикации във форумите
    Тази библиотека ползва регулярни изрази, за да си свърши работата
    Променен регулярен израз между версия 1.1.0 и 1.1.1
    Проблемният commit може да [видите тук](https://github.com/tenderlove/rails_autolink/commit/8dd71913a7863209750ce8e4b81a574d3e3c5bf8#diff-15c62fa505488630c537c5c1962ff08d)
    Изглежда и други хора се [бяха опарили](https://github.com/tenderlove/rails_autolink/issues/34)

= slide 'Изводи', 'Да пишеш софтуер не е лесна работа...' do
  list:
    Разработката за уеб обхваща много слоеве и има множество движещи се части
    Познавайте инструментите си
    Познавайте стека, на който стъпвате:
    ОС (Linux/Unix), уеб сървър (Nginx/Apache), application server (Passenger, Unicorn, Puma, ...)
    Мониторирайте софтуера си (Pingdom и подобни услуги)
    Внимавайте с външните зависимости на проекта си -- колкото по-малко, толкова по-добре
    Дебъгвайте спокойно и съсредоточено, мислете на всяка стъпка
    Правете си изводи
    Внимавайте много с регулярните изрази :)
    Вижте секцията [Performance от документацията](http://www.ruby-doc.org/core-2.1.0/Regexp.html#class-Regexp-label-Performance)

= slide 'Произход', 'малко обща култура' do
  list:
    На възраст над 60 години (Клини, regular sets, ок. 1950 г.)
    Practical Extraction and Report Language
    Perl и PCRE-библиотеката (Perl-Compatible Regular Expressions)
    Почти всеки general-purpose програмен език имплементира някаква форма на РИ
    Незаменими unix-програми като `grep`, `sed`, `awk`, `vi`, `Emacs`...
    Разглеждат се в курса по ДМ покрай граматики и автомати

= slide 'Проблемна област', 'най-общо: работа с текстови низове' do
  list:
    Търсене на по-сложна последователност от символи в низ
    Заместване на такива последователности с нещо друго
    Модифициране на текстови последователности (например, Markdown към HTML)
    Проверка дали даден низ отговаря на определени условия (валидация)
    Проверка дали едно число е просто или не :) Не.

= slide 'Понятия', 'и терминология' do
  list:
    „шаблон“, още „регулярен израз“ (pattern)
    Специални символи (meta characters)
    Екраниране на специалните символи (escape-ване)
    Повторители и повторение (quantifiers and repetition)
    Класове от символи (character classes)
    Групи
    Флагове (modifiers) на шаблона

= slide 'РИ в Ruby', 'синтаксис, накратко' do
  list:
    Всеки регулярен израз е обект, инстанция на класа `Regexp`
    Има литерален синтаксис за създаване на регулярни изрази: `/pattern/`
    Може да се ползва и синтаксисът с `%r`, например: `%r{/path/maching/made/easy}`
    Операциите с регулярни изрази са методи на `Regexp`
    Класът `String` също има методи за работа с регулярни изрази

= slide 'Regexp#match', 'ще го ползваме в примерите' do
  list:
    За да демонстрираме какво "хващат" определени шаблони, ще ползваме `Regexp#match`
    Този метод примеа аргумент текстов низ и връща `nil`, ако шаблонът не "хваща" нищо
    Връща инстанция на `MatchData`, ако шаблонът "хваща" нещо от низа
    `MatchData` в детайли — по-късно
    От тук нататък ще ползваме <em>match-ва</em> като синоним на <em>"хваща"</em> :)

= slide 'Шаблони', '(регулярни изрази, patterns и т.н.)' do
  list:
    В сърцето на всеки регулярен израз стои шаблон (pattern)
    В шаблона, всеки символ (освен някои специални) означава себе си
    Следователно, шаблонът `/wool/` ще отговаря на точно тази последователност от символи в низ
    Цялата магия е в специалните символи:
    `(`, `)`, `[`, `]`, `{`, `}`, `.`, `?`, `+`, `*`, `^`, `$`, `\`, ...
    Някои символи са специални само в определен контекст (например символът `-`)

= slide 'Най-прост пример' do
  annotate:
    /find me/.match 'Can you find me here?' # =>
    /find me/.match 'You will not find ME!' # =>
  list:
    Този шаблон не съдържа специални символи
    Както виждате, по подразбиране шаблоните са чувствителни към регистъра на буквите
    Последното може да се контролира с помощта на флагове към шаблона

= slide 'Специални символи', 'meta characters' do
  list:
    `.` съвпада с един произволен символ (с изключение на символите за нов ред)
    `[` и `]` се ползват за дефиниране на класове от символи
    `*`, `?`, `+`, `{` и `}` се ползват за указване на повторения
    `^`, `$`, `\b`, `\B` и т.н. са "котви" и съответстват на определени "междусимволни дупки" :)
    `|` има смисъл на "или", например:
  div.action
    annotate:
      /day|nice/.match  'A nice dance-day.'  # =>
      /da(y|n)ce/.match 'A nice dance-day.'  # =>

  p.action Внимавайте с приоритета на <code>|</code>

= slide 'Екраниране', 'на специалните символи (escape-ване)' do
  list:
    `\` пред специален символ го прави неспециален такъв (екранира го)
    За да вкарате наклонена черта, ползвате `\\` (като в обикновен низ)

= slide 'Класове от символи', '(character classes)' do
  list:
    Заградени между `[` и `]`
    Наподобяват множества
    Match-ват един символ от посочените вътре
    Могат да се декларират диапазони, например `[a-z]` или `[0-9A-F]`
    Ако първият символ в класа е `^`, това означава "някой символ, който не е посочен в класа"
    Можете да екранирате тире в символен клас така: `[a\-b]`
    Друг вариант е да сложите тирето в началото или в края на класа: `[-abc]` или `[abc-]` - тук то няма специален смисъл
    Има предефинирани класове от символи

= slide 'Примери с класове от символи' do
  annotate:
    /W[aeiou]rd/.match "Word" # =>
    /[0-9a-f]/.match '9f'     # =>
    /[9f]/.match     '9f'     # =>
    /[^a-z]/.match   '9f'     # =>

= slide 'Предефинирани класове от символи' do
  list:
    `\w` - символ от дума (`[a-zA-Z0-9_]`)
    `\W` - символ, който не може да участва в дума (`[^a-zA-Z0-9_]`)
    `\d` - цифра ([0-9])
    `\D` - символ, който не е цифра (`[^0-9]`)
    `\h` - шеснадесетична цифра (`[0-9a-fA-F]`)
    `\H` - символ, който не е шеснадесетична цифра (`[^0-9a-fA-F]`)
    `\s` - whitespace-символ (`/[ \t\r\n\f]/`)
    `\S` - символ, който не е whitespace (`/[^ \t\r\n\f]/`)

= slide 'POSIX-класове от символи' do
  list:
    `[[:alpha:]]` - символ от азбука
    `[[:alnum:]]` - горното или цифра
    `[[:blank:]]` - интервал или таб
    `[[:cntrl:]]` - контролен символ
    `[[:digit:]]` - цифра
    `[[:lower:]]` - малка буква
    `[[:upper:]]` - главна буква
    `[[:print:]]` - printable-символ
    `[[:punct:]]` - пунктуационен символ
    `[[:space:]]` - whitespace-символ (вкл. и нов ред)
    `[[:xdigit:]]` - шеснадеситична цифра
    И други...

= slide 'Полезни не-POSIX класове' do
  list:
    Ruby поддържа и следните не-POSIX символни класове:
    `[[:word:]]` - символ, който може да участва в дума (работи и за Unicode, за разлика от `\w`)
    `[[:ascii:]]` - ASCII-символ

= slide 'Символни свойства', 'character properties' do
  list:
    С конструкцията `\p{}` може да match-вате символи, имащи определено свойство (подобно на POSIX)
    Например: `\p{Alnum}`, `\p{Alpha}`, `\p{Blank}`, `\p{Cntrl}`, `\p{Digit}`, `\p{Graph}`
    По този начин, например, може да проверите дали даден символ е от японската азбука катакана: `\p{Katakana}`
    Или пък да match-нете символ от азбука на кирилица: `\p{Cyrillic}`, например:

  div.action
    annotate:
      /\s\p{Cyrillic}\p{Cyrillic}\p{Cyrillic}/.match 'Ние сме на всеки километър!' # #<MatchData " сме">

= slide 'Котви' do
  list:
    Не съвпадат с реални символи, а вместо това с невидимите граници между тях
    `^` съвпада с началото на ред (Ruby е в multiline режим по подразбиране)
    `$` съвпада с края на ред
    `\A` съвпада с началото на текстов низ
    `\z` съвпада с края на низ
    `\b` отговаря на граница на дума (когато е извън `[` и `]`; вътре означава `backspace`)
    `\B` отговаря на място, което не е граница на дума

= slide 'Примери с котви' do
  annotate:
    /real/.match "surrealist"    # =>
    /\Areal/.match "surrealist"  # =>
    /\band/.match "Demand"       # =>

    /\Band.+/.match "Supply and demand curve" # =>

= slide 'Повторители', '(quantifiers)' do
  list:
    Важат за непосредствено предхождащия ги символ/клас/група; нека го означим със `s`
    `s*` означава нула или повече повторения на `s`
    `s+` търси едно или повече повторения на `s`
    `s?` съвпада с нула или едно повторение на `s`
    `s{m,n}` означава между m и n повторения на `s`
    В последното можем да пропуснем `m` или `n`:
    `s{,n}` има смисъл на нула до `n` повторения, а `s{m,}` — поне `m` повторения
    `s{n}` означава точно `n` повторения

= slide 'Примери с повторители' do
  annotate:
    /e+/.match     'Keeewl'       # =>
    /[Kke]+/.match 'Keeewl'       # =>
    /\w+/.match '2038 - the year' # =>
    /".*"/.match '"Quoted text!"' # =>

    /[[:upper:]]+[[:lower:]]+l{2}o/.match 'Hello' # =>

= slide 'Алчност', 'и лакомия...' do
  list:
    По подразбиране повторителите са "алчни", т.е. изяждат колкото се може повече от низа
    Това поведение може да се контролира с `?` след повторителя
    Например `.*?` кара повторителя `*` да се държи не-лакомо
    Внимавайте с лакомите повторители
  div.action
    annotate:
      /<.+>/.match("<a><b>")  # =>
      /<.+?>/.match("<a><b>") # =>

= slide 'Групи', 'и прихващане' do
  p Символите <code>(</code> и <code>)</code> се използват за логическо групиране на части от шаблона с цел:
  list:
    Контролиране областта на влияние на дадена операция
    Например, следното ще match-ва низове, съдържащи думите `day` или `dance`: `/\bda(y|nce)\b/`
    Възможност за референция към „ограденото“ в скобите — в и извън шаблона
    Задаване на по-специални (и не толкова често употребявани) конструкции
    Групите биват номерирани или именовани

= slide 'Референции към групи' do
  p Текстът, който match-ва частта на шаблона, оградена в скоби, може да се достъпва:
  list:
    В самия шаблон, с нотацията `\1` за първата група, `\2` за втората и т.н.
    Отвън, през `MatchData`-обекта
    Отвън, през специални променливи от типа на `$1`, `$2`... за номерирани групи
    Отвън, през локални променливи, за именовани групи

= slide 'Референции към групи', 'извън шаблона, за номерирани групи, през MatchData' do
  example:
    date_string = '2012-11-12'
    date_parts  = /\A(\d{4})-(\d\d)-(\d\d)\z/.match(date_string)

    if date_parts
      Date.new date_parts[1].to_i, date_parts[2].to_i, date_parts[3].to_i
      # #<Date: 2012-11-12 ...>
    end


= slide 'if с регулярни изрази' do
  list:
    `=~` и `!~` — дефинирани в `Regexp` и в `String`
    Можем да правим така: `/pattern/ =~ 'Some string'`
    Както и така: `'Some string' =~ /pattern/`
    Връща `nil`, ако няма съвпадение, или число (offset), ако има такова
    След изпълнение на този оператор също имаме попълнени специални променливи (`$1`, `$~`...)
    Удобно е да се ползва в условни конструкции, например `if`

= slide 'if с регулярни изрази', 'пример' do
  annotate:
    log_entry = "[2011-07-22 15:42:12] - GET / HTTP/1.1 200 OK"

    if log_entry =~ /\bHTTP\/1\.1 (\d+)/
      request_status = $1.to_i # =>
    else
      raise "Malformed log entry!"
    end

= slide 'Референции към групи', 'извън шаблона, за номерирани групи, през $1, $2...' do
  example:
    date_string = '2012-11-12'

    if date_string =~ /\A(\d{4})-(\d\d)-(\d\d)\z/
      Date.new $1.to_i, $2.to_i, $3.to_i # #<Date: 2012-11-12 ...>
    end

= slide 'Именовани групи' do
  list:
    Като обикновена група, само че се обръщате към тях не с цифра, а с име
    Дефинират се така: `(?&lt;name&gt;)` или така: `(?'name')`, където `name` е името на групата
    Например: `(?&lt;date&gt;\d{4}-\d{2}-\d{2})`
  div.action
    annotate:
      /(?<date>\d{4}-\d{2}-\d{2})/.match 'Today is 2011-11-08, Tuesday.' # =>

= slide 'Референции към групи', 'в рамките на шаблона' do
  list:
    `\1`, `\2` и прочее, ако групите ви не са именовани
    Ако имате повече от 9 групи, можете да ги реферирате по същия начин:
    `\11` се обръща към 11-тата група
    Ами ако искам да кажа: "текстът, отговарящ на група `\1`, последван от символа `1`"?
    Ползвате следния общ синтаксис: `\k&lt;group_identifier&gt;`, където `group_identifier` е число или име на група
    Този общ синтаксис се използва и за обръщение към текста, отговарящ на именовани групи:
    `/(?&lt;word&gt;\w+), \k&lt;word&gt;/`

= slide 'Примери за референции към групи' do
  example:
    /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/.match 'Today is 2011-11-08, Tuesday.'
    # #<MatchData "2011-11-08" year:"2011" month:"11" day:"08">

    /(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)\11/.match 'Regular expressions'
    # #<MatchData "ular express" 1:"u" 2:"l" 3:"a" 4:"r" 5:" " 6:"e" 7:"x" 8:"p" 9:"r" 10:"e" 11:"s">
    /(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)\k<11>1/.match 'Regular express1ions'
    # #<MatchData "ular express1" 1:"u" 2:"l" 3:"a" 4:"r" 5:" " 6:"e" 7:"x" 8:"p" 9:"r" 10:"e" 11:"s">

  list:
    Забележете, че в рамките на един шаблон <strong>не може</strong> да ползвате и двата вида рефериране към групи

= slide 'Уточнение относно референциите', 'в рамките на шаблона' do
  list:
    Обърнете внимание, че референцията е към порцията текст, match-нат от групата, а не към самата група!
    Например:
  div.action
    annotate:
      /(\w+), \1/.match 'testing, testing' # =>
      /(\w+), \1/.match 'testing, twice'   # =>

      /(?<word>\w+), \k<word>/.match 'testing, testing' # =>

= slide 'Backtracking' do
  list:
    Често срещан термин в регулярните изрази, свързан с имплементацията им
    Често се случва, когато имате "алчни" повторители
    Ето пример как работи:

  .action
    annotate:
      /".*"/.match '"Quoted"' # =>

    p Частта от шаблона <code>.*</code> хваща <code>Quoted"</code>, тъй като е алчна. Това води до невъзможност да се намери съвпадение и алгоритъмът backtrack-ва -- връща се една стъпка/символ назад.

= slide 'Атомарни (неделими) групи' do
  list:
    Атомарните (неделими) групи могат да променят това поведение
    Атомарна група се дефинира така: `(?>pattern)`
    Според документацията, се ползват за оптимизация и предотвратяване на излишно backtrack-ване
    Например:

  .action
    annotate:
      /"(?>.*)"/.match('"Quote"') # =>

= slide 'Рекурсивни групи' do
  list:
    Ако вместо порцията текст, отговаряща на дадена група, искате да преизпълните групата?
    Ползвате следния синтаксис: `\g&lt;name&gt;`, където `name` е номер или име на група в шаблона
    Това <strong>преизпълнява</strong> шаблона, не търси за вече намерения текст
    Има смисъл за да направи шаблоните ви една идея по-DRY
    Например:
  div.action
    annotate:
      /(\w+), \1/.match    'testing, twice'   # =>
      /(\w+), \g<1>/.match 'testing, twice'   # =>

= slide 'Рекурсивни групи', 'втора част' do
  list:
    С помощта на горното можете да дефинирате рекурсивни групи
    Спомняте ли си втория проблем, който поставихме в началото?
  blockquote.action
    | Да валидирате изрази от следния тип за правилно отворени/затворени скоби:
    list:
      `(car (car (car ...)))`
      Например: `(car (car (car (car list))))`
      Целта е израз, чийто резултат да може да се ползва в условен оператор (`true`/`false`-еквивалент)
      Можете да ползвате произволни методи от класа `Regexp`
      И регулярен израз, разбира се

= slide 'Примерно решение', 'с рекурсивни групи' do
  annotate:
    validator = /^(\(car (\g<1>*|\w*)\))$/

    valid   = '(car (car (car (car list))))'
    invalid = '(car (car (car list))'

    validator.match(valid)   ? true : false # =>
    validator.match(invalid) ? true : false # =>

= slide 'Просто число с регулярен израз' do
  list:
    Решение – идния понеделник
    Междувременно, помислете сами как би могло да стане
    Подсказка – не търсете подсказки... :)

= slide 'Следва продължение' do
  p Следващата седмица ще довършим темата за регулярните изрази.
