= slide 'Проекти' do
  list:
    Носят до 60 точки, срокът за писането им е до датата на защита (в сесията)
    Вие си избирате тема и ни пишете на [fmi@ruby.bg](mailto:fmi@ruby.bg), ние я одобряваме
    Размер и сложност - 10 задачи или 60 предизвикателства :)
    Най-епичното и масивно нещо, което сте писали на Ruby
    Крайният срок да си изберете тема и <strong>да ви я одобрим</strong>, е <strong>24.12.2014</strong>, 23:59:59 (ще има новина с инструкции)
    Запознайте се с [ръководството и някои ЧЗВ около проектите](https://github.com/fmi/ruby-course-guides/blob/master/course_projects.md#readme)

= slide 'Проекти - точкуване, изисквания, планиране' do
  list:
    60-те точки са разделени на три - функционалност, стил и дизайн (на кода), тестове
    Най-важното нещо за проектите - ще ви трябва време
    Наистина, ще ви глътнат много време
    Добре е да си изберете тема, която ви харесва, но е по-важно да си изберете <strong>някаква</strong> тема рано
    [Ръководството дава повече подробности](https://github.com/fmi/ruby-course-guides/blob/master/course_projects.md#readme), като ще пуснем и тема във форумите
    При нужда, ще допълваме ръководството с още информация

= slide 'Основна цел на проектите' do
  list:
    Да прекарате време с Ruby, написвайки нещо по-голямо от 100-ина реда код
    Да експериментирате с нови неща, с които не сте до момента
    Добър пример за горното са процеси като test-driven development и изобщо писане на тестове
    Постарайте се да направите добра архитектура (добра != сложна)
    Темата на проекта не е толкова важна; важно е научаването на нови неща и времето, което ще прекарате в борба с различни проблеми

= slide 'Въпрос 1' do
  p Каква е рализката между следните?
  example:
    /(\w+), \g<1>/.match 'something, fishy' # => ?
    /(\w+), \1/.match    'something, fishy' # => ?

= slide 'Въпрос 1' do
  p Каква е рализката между следните?
  annotate:
    /(\w+), \g<1>/.match 'something, fishy'   # =>
    /(\w+), \1/.match    'something, fishy'   # =>
  .action.answer
    p <code>\1</code> match-ва match-натото от първата група. <code>\g<1></code> преизпълнява pattern-а на групата.

= slide 'Въпрос 2' do
  p Какъв ще бъде резултатът?
  example:
    /(\b\w+\b\s){4}\g<1>/.match 'the right person in the wrong place...'
    $1 # => ?

= slide 'Въпрос 2' do
  p Какъв ще бъде резултатът?
  annotate:
    /(\b\w+\b\s){4}\g<1>/.match 'the right person in the wrong place...'
    $1   # =>
  .action.answer
    p <code>$1</code> се променя при всяко ново match-ване на групата. В това число и когато я преизпълните рекурсивно.

= slide 'Въпрос 3' do
  p Къде и колко (не е нужно точно число) ще се backtrack-не:
  annotate:
    /.*?hi.*there/.match 'om, nom, nom... oh hi there...'
  .action.answer
    p <code>.*?</code> ще започне от 0 символа и ще увеличава с един за всичко преди <code>hi</code>. <code>.*</code> ще започне с целия низ след <code>hi</code> и ще намаля с един, докато не стигне до началото на <code>there</code>.

= slide 'Кратък преговор от миналия път' do
  list:
    Регулярните изрази в Ruby - инстанции на `Regexp`
    Всеки символ "съвпада" със себе си, с изключение на някои специални
    Специални символи: `(`, `)`, `[`, `]`, `{`, `}`, `.`, `?`, `+`, `*`, `^`, `$`, `\`, ...
    Екранират (escape-ват) се с `\`
    Литерален синтаксис: `/foobar/` или `%r(/some/path)`

= slide 'Лятна предприемаческа програма', 'Summer Entrepreneurship Program' do
  p
    a href="http://www.iie.org/Programs/Bulgarian-Young-Leaders-Program/SEP" iie.org/Programs/Bulgarian-Young-Leaders-Program/SEP

= slide 'Какво е това?' do
  list:
    5 седмици през лятото (~10.07 - ~ 20.08)
    Покрити пътуване, настаняване, храна до и в САЩ.
    За редовни студенти – български граждани в български университети.
    Обучение в Babson College, N1 по предприемачество в класацията на Щатските университети.
    Втори модул в Сан Франциско – потапяне в Силициевата Долина, и начинът, по който там се върши бизнес.
    Обучение – в екипи от 5-6 души се измисля и разработва бизнес модел за стартъп.

= slide 'Защо искам да отида?' do
  list:
    Искам да отида до Щатите, но на чужди разноски.
    Времето ми е твърде ценно, за да мия чинии.
    Искам не само да правя добри продукти, но и да умея да ги насочвам към правилните хора, продавам и развивам в перспектива.
    Искам да се запозная с различни от мен, но също толкова надъхани и амбициозни хора.
    Искам да придобия нови знания и опит в области, различни от тази, в която съм специалист.
    Искам да посетя Силициевата долина и да видя как се прави този бизнес в наистина голям мащаб.

= slide 'Защо има смисъл да отида?' do
  list:
    На всеки стартъп му липсва „ИТ човек”.
    В програмата като цяло има много мениджъри и малко от хората, които реално могат да направят нещо. Много вожд, малко индианец.
    Прекрасна възможност да се научите да работите и да развивате продукт заедно с неспециалисти.
    Да участвате в измислянето на това, по което ще работите.
    Да видите как се разработва продаваем и размножаем (scalable) продукт.

= slide 'Как да кандидатствам?' do
  list:
    Попълвам онлайн формуляр.
    Две мотивационни есета.
    Две препоръки.
    Академична справка (!) – обикновено отнема минимум 2 седмици да излезе.
    Изпит по английски – TOEFL.
    Интервю.

= slide 'Информационна среща и ресурси' do
  list:
    Утре, 11.12, от 19.30 в УАСГ – студио Прожектиране
    [Facebook събитие](https://www.facebook.com/events/605454969560768/) (или пишете на Марта)
    [Сайт на програмата](http://www.iie.org/Programs/Bulgarian-Young-Leaders-Program/SEP)

= slide 'MOAR, MOAR!!!!111!' do
  blockquote
    | Проверете дали нещо е валиден математически израз
    list:
      Произволно цяло число `1337`
      Променлива (малка латинска буква) `x`
      Знак пред валиден израз (+, -) `-33 + 22 * -y`
      Операция между валидни изрази (+, -, *, /) `x + y - 21 / 3`
      Скоби, ограждащи валидни изрази `-x * (y + -5 * (7 - 13)) / 44 - 9000`

= slide 'Примерно решение', 'so simple, right?' do
  example:
    validator = /^([-+]?(\d+|[a-z]|\(\g<1>\)|\g<1> [-+*\/] \g<1>))$/

    valid   = '-(3 + (x * (7 / y))) * (44 * y - z / 22)'
    invalid = '((33 - 7) * x'

    validator.match(valid)   ? true : false
    validator.match(invalid) ? true : false

= slide 'Примерно решение', 'nope... fail!' do
  annotate:
    /^([-+]?(\d+|[a-z]|\(\g<1>\)|\g<1> [-+*\/] \g<1>))$/

= slide 'Примерно решение', 'с рекурсивни групи' do
  annotate:
    validator = /^([-+]?(\d+|[a-z]|\(\g<1>\))( [-+*\/] \g<1>)?)$/

    valid   = '-(3 + (x * (7 / y))) * (44 * y - z / 22)'
    invalid = '((33 - 7) * x'

    validator.match(valid)   ? true : false # =>
    validator.match(invalid) ? true : false # =>

= slide 'Look-ahead и look-behind' do
  list:
    Положителен look-ahead: `/(?=pattern)/`
    Отрицателен look-ahead: `/(?!pattern)/`
    Положителен look-behind: `/(?&lt;=pattern)/`
    Отрицателен look-behind: `/(?&lt;!pattern)/`
    Пример:
  div.action
    annotate:
      /(?<=<b>)\w+(?=<\/b>)/.match("Fortune favours the <b>bold</b>") # =>

= slide 'Пример' do
  blockquote
    | Сменете * на % ако тя не е екранирана (escape-ната)
    list:
      `foo*`     => `foo%`
      `foo\*`    => `foo\*`
      `foo\\\\*` => `foo\\\\%`
      `*\\\**`    => `%\\\*%`

= slide 'Първи начин' do
  div.action
    annotate:
      "*\\**".gsub(/((?<!\\)(?:\\\\)*)\*/, '\1%') # =>
  list:
    Група 1 евентуално държи четни наброй `\`, които нямат пред себе си `\`
    После ловим `*` и готово :)

= slide 'Втори начин' do
  div.action
    annotate:
      "*\\**".gsub(/\G([^*\\]*(?:\\.[^*\\]*)*)\*/, '\1%') # =>
  list:
    Сложно...

= slide 'Интерполация в регулярни изрази' do
  p Между другото, регулярните изрази поддържат интерполация по подразбиране:

  annotate:
    name      = /[^@]+/
    host      = /\w+\.(com|net|org)/

    email     = /#{name}@#{host}/ # =>

= slide 'Работа с MatchData-обекти' do
  list:
    Това е обектът, който ви връща `Regexp#match`
    Това е обектът, стоящ зад специалната променлива `$~`
    Същият обект се крие и зад `Regexp.last_match`
    Не е `Enumerable`

= slide 'Най-полезни методи на MatchData-обектите' do
  list:
    `MatchData#[група]`, където `група` е номер или име на група, ви връща порцията текст, отговаряща на съответната група
    `MatchData#begin(група)` пък ви връща число — отместването спрямо началото на низа на порцията текст, отговаряща на съответната група
    Пример:
  div.action
    annotate:
      /(\w+)/.match('Some words')[1]              # =>
      /(\w+)/.match('Some words').begin(1)        # =>
      /(?<id>\d+)/.match('ID: 12345')[:id]        # =>
      /(?<id>\d+)/.match('ID: 12345').begin(:id)  # =>

= slide '#pre_match и #post_match методи', 'на MatchData-обектите' do
  list:
    `MatchData#pre_match` (същото като специалната променлива <code>$`</code>) — текстът преди съвпадението
    `MatchData#post_match` (същото като специалната променлива <code>$'</code>) — текстът след съвпадението
    Пример:
  div.action
    annotate:
      match = /(?<number>\d+)/.match 'ID: 12345 (new)'

      match[:number]    # =>
      match.pre_match   # =>
      match.post_match  # =>

= slide 'Специалните променливи' do
  list:
    `$~`, `$'`, `$1`, `$2`, `$3` и прочее
    Не са глобални променливи, а специални - thread-local и method-local, т.е. не са глобално-видими
    Попълват се с резултата от последно изпълнения `match`
    Не само след явно извикване на `Regexp#match`

= slide 'case с регулярни изрази', 'работи благодарение на Regexp#===' do
  example:
    html = '<h1>Header</h1>' # или:
    html = '<img src="http://my/image.src" alt="Kartman Makes Burgers" />'

    case html
      when /(<h(\d)>)(.+)<\/h\2>/
        {header: $3, size: $2}
      when /<a\s+href="([^"]+)">([^<]+)<\/a>/
        {url: $1, text: $2}
      when /<img\s+src="([^"]+)"\s+alt="([^"]+)"\s*\/>/
        {image: $1, alt: $2}
      else
        'unrecognized tag'
    end

    # {:image=>"http://my/image.src", :alt=>"Kartman Makes Burgers"}

= slide 'Методи в String', 'свързани с регулярни изрази' do
  list:
    `String#match`
    `String#=~` и `String#!~`
    `String#sub`, `String#gsub` и вариантите им с `!`
    `String#[]` и `String#slice` - в някои от вариантите си приемат регулярен израз
    `String#index` и `rindex` приемат и регулярен израз
    `String#partition` и `rpartition` и <a href="http://www.ruby-doc.org/core-2.1.5/String.html">други...</a>

= slide 'Пример със String#gsub', 'плюс групи и блок' do
  example:
    'SomeTitleCase'.gsub /(^|[[:lower:]])([[:upper:]])/ do
      [$1, $2.downcase].reject(&:empty?).join('_')
    end

    # "some_title_case"

= slide 'Encoding' do
  p Цитат от документацията:
  blockquote
    |
      A regexp can be matched against a string when they either share an encoding,
      or the regexp’s encoding is US-ASCII and the string’s encoding is ASCII-compatible.

= slide 'Encoding & Unicode' do
  list:
    Регулярните изрази в Ruby 2.1 носят кодировката на сорс-кода
    Можете да проверите кодировката на даден регулярен израз с `Regexp#encoding`
    Можете да укажете изрична кодировка посредством модификатор; например `/something/u` за `UTF-8`
    Малък пример:

  blockquote.action
    | Rubyのお父さんはまつもとゆきひろさんです。

  .action
    example:
      unicode_test = 'Rubyのお父さんはまつもとゆきひろさんです。'

      /は[[:alpha:]]+さん/.match unicode_test # #<MatchData "はまつもとゆきひろさん">

= slide 'Граници на думи в Unicode-текст' do
  list:
    `\b` в Unicode-текст работи, когато границата на думата е лесно определима
    Например, това ще работи: `/\b[[:alpha:]]\b/.match 'това и онова' # #&lt;MatchData "и"&gt;`
    Горното работи, понеже думата на кирилица е оградена от интервали
    В някои езици, обаче, няма интервали (whitespace) между думите (например китайски, японски)
    Къде са границите на думите в това изречение: `Rubyのお父さんはまつもとゆきひろさんです。`?

= slide 'Граници на думи в Unicode-текст', 'пример' do
  p Например:
  div.action
    example:
      'Ruby no otousan ha Matsumoto Yukihiro san desu.'.gsub(/(\b[[:alpha:]]+\b)/) { "[#{$1}]" }
      # "[Ruby] [no] [otousan] [ha] [Matsumoto] [Yukihiro] [san] [desu]."

  p.action Но:
  div.action
    example:
      'Rubyのお父さんはまつもとゆきひろさんです。'.gsub(/(\b[[:alpha:]]+\b)/) { "[#{$1}]" }
      # "[Rubyのお父さんはまつもとゆきひろさんです]。"

= slide 'Флагове на шаблоните' do
  list:
    Можете да управлявате някои аспекти от поведението на шаблона посредством флагове
    Указват се след края на шаблона, например: `/pattern/flags`
    `i` прави търсенето на съвпадение нечувствително към регистъра на буквите
    `u` кара шаблона да носи задължителна кодировка `UTF-8`
    `m` превръща шаблона в multiline-такъв (в този режим, например, `.` ще съвпада и с нов ред)
    Има и други, които не се ползват толкова често

= slide 'Условия в шаблоните (if)', 'Ново в Ruby 2.0' do
  list:
    Ruby 2.0 и по-нови ползват библиотеката Onigmo за регулярни изрази
    Там има някои нововъведения, например това: `(?(cond)yes|no)`
    `cond` може да е референция към друга група в шаблона, или пък look-ahead/behind
    Пример:

  .action
    annotate:
      regexp = /^(number)?\s*(?(1)\d+|[a-zA-Z]+)$/

      regexp =~ "number 123"   # =>
      regexp =~ "foo"          # =>
      regexp =~ "number baz"   # =>

= slide 'Документация' do
  list:
    `Regexp`: <a href="http://www.ruby-doc.org/core-2.1.5/Regexp.html">http://www.ruby-doc.org/core-2.1.5/Regexp.html</a>
    `MatchData`: <a href="http://www.ruby-doc.org/core-2.1.5/MatchData.html">http://www.ruby-doc.org/core-2.1.5/MatchData.html</a>
    `String`: <a href="http://www.ruby-doc.org/core-2.1.5/String.html">http://www.ruby-doc.org/core-2.1.5/String.html</a>
    През `ri`, например: `ri Regexp#=~`